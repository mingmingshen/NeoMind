//! LLM-based decision recommendation system.
//!
//! This module provides decision-making capabilities using LLM
//! to generate actionable recommendations from system analysis.

use std::collections::HashMap;
use std::sync::Arc;

use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;

use crate::llm::LlmInterface;
use edge_ai_core::event::{NeoTalkEvent, ProposedAction};
use edge_ai_core::eventbus::EventBus;

use super::review::{DetectedIssue, IssueSeverity, Recommendation, ReviewResult};

/// Decision generated by LLM analysis.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Decision {
    /// Unique decision ID
    pub id: String,
    /// Decision title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Reasoning behind the decision
    pub reasoning: String,
    /// Suggested actions to take
    pub actions: Vec<DecisionAction>,
    /// Confidence level (0-100)
    pub confidence: f32,
    /// Decision type
    pub decision_type: DecisionType,
    /// Priority level
    pub priority: DecisionPriority,
    /// Estimated impact
    pub impact: ImpactAssessment,
    /// Source review (if applicable)
    pub source_review: Option<String>,
    /// Timestamp when decision was created
    pub created_at: i64,
    /// Timestamp when decision expires
    pub expires_at: Option<i64>,
    /// Execution status
    pub status: DecisionStatus,
}

/// Decision action to be executed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionAction {
    /// Action ID
    pub id: String,
    /// Action type
    pub action_type: String,
    /// Action description
    pub description: String,
    /// Parameters for the action
    pub parameters: serde_json::Value,
    /// Expected outcome
    pub expected_outcome: String,
    /// Whether this action is required
    pub required: bool,
}

/// Type of decision.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DecisionType {
    /// Automation rule creation/modification
    Rule,
    /// Device control action
    DeviceControl,
    /// Alert/notification
    Alert,
    /// Workflow trigger
    Workflow,
    /// Configuration change
    Configuration,
    /// Data collection request
    DataCollection,
    /// Human intervention required
    HumanIntervention,
}

/// Priority level for decisions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DecisionPriority {
    Low,
    Medium,
    High,
    Critical,
}

/// Assessment of decision impact.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImpactAssessment {
    /// Expected benefit
    pub benefit: String,
    /// Potential risks
    pub risks: Vec<String>,
    /// Resource requirements
    pub resources: Vec<String>,
    /// Estimated time to implement
    pub estimated_time: Option<String>,
}

/// Status of a decision.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DecisionStatus {
    Proposed,
    Approved,
    Rejected,
    Executed,
    Failed,
    Expired,
}

impl Decision {
    /// Create a new decision.
    pub fn new(
        title: String,
        description: String,
        reasoning: String,
        decision_type: DecisionType,
        priority: DecisionPriority,
    ) -> Self {
        let id = uuid::Uuid::new_v4().to_string();
        Self {
            id,
            title,
            description,
            reasoning,
            actions: Vec::new(),
            confidence: 50.0,
            decision_type,
            priority,
            impact: ImpactAssessment {
                benefit: String::new(),
                risks: Vec::new(),
                resources: Vec::new(),
                estimated_time: None,
            },
            source_review: None,
            created_at: chrono::Utc::now().timestamp(),
            expires_at: None,
            status: DecisionStatus::Proposed,
        }
    }

    /// Add an action to the decision.
    pub fn with_action(mut self, action: DecisionAction) -> Self {
        self.actions.push(action);
        self
    }

    /// Set the confidence level.
    pub fn with_confidence(mut self, confidence: f32) -> Self {
        self.confidence = confidence.clamp(0.0, 100.0);
        self
    }

    /// Set the impact assessment.
    pub fn with_impact(mut self, impact: ImpactAssessment) -> Self {
        self.impact = impact;
        self
    }

    /// Check if the decision is still valid.
    pub fn is_valid(&self) -> bool {
        if let Some(expires_at) = self.expires_at {
            chrono::Utc::now().timestamp() < expires_at
        } else {
            true
        }
    }

    /// Check if the decision should be auto-executed.
    pub fn should_auto_execute(&self) -> bool {
        self.confidence >= 80.0
            && self.priority >= DecisionPriority::High
            && self.status == DecisionStatus::Proposed
            && self.is_valid()
    }
}

impl DecisionAction {
    /// Create a new decision action.
    pub fn new(action_type: String, description: String, parameters: serde_json::Value) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            action_type,
            description,
            parameters,
            expected_outcome: String::new(),
            required: false,
        }
    }

    /// Set the expected outcome.
    pub fn with_expected_outcome(mut self, outcome: String) -> Self {
        self.expected_outcome = outcome;
        self
    }

    /// Set whether this action is required.
    pub fn with_required(mut self, required: bool) -> Self {
        self.required = required;
        self
    }
}

/// LLM decision engine for generating recommendations.
pub struct DecisionEngine {
    /// LLM interface for generating decisions
    _llm: Arc<RwLock<LlmInterface>>,
    /// Event bus for publishing decision events
    event_bus: Arc<EventBus>,
    /// Decision history
    history: Arc<RwLock<HashMap<String, Decision>>>,
    /// Configuration for the engine
    config: DecisionEngineConfig,
}

/// Configuration for the decision engine.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionEngineConfig {
    /// Minimum confidence threshold for auto-execution
    pub auto_execute_threshold: f32,
    /// Decision lifetime in seconds
    pub decision_lifetime_secs: i64,
    /// Maximum number of decisions to keep in history
    pub max_history_size: usize,
}

impl Default for DecisionEngineConfig {
    fn default() -> Self {
        Self {
            auto_execute_threshold: 80.0,
            decision_lifetime_secs: 86400, // 24 hours
            max_history_size: 1000,
        }
    }
}

impl DecisionEngine {
    /// Create a new decision engine.
    pub fn new(llm: Arc<RwLock<LlmInterface>>, event_bus: Arc<EventBus>) -> Self {
        Self {
            _llm: llm,
            event_bus,
            history: Arc::new(RwLock::new(HashMap::new())),
            config: DecisionEngineConfig::default(),
        }
    }

    /// Create with custom configuration.
    pub fn with_config(
        llm: Arc<RwLock<LlmInterface>>,
        event_bus: Arc<EventBus>,
        config: DecisionEngineConfig,
    ) -> Self {
        Self {
            _llm: llm,
            event_bus,
            history: Arc::new(RwLock::new(HashMap::new())),
            config,
        }
    }

    /// Generate decisions from a review result.
    pub async fn generate_decisions_from_review(
        &self,
        review_result: &ReviewResult,
    ) -> Vec<Decision> {
        match review_result {
            ReviewResult::Findings {
                summary: _,
                issues,
                recommendations,
            } => {
                let mut decisions = Vec::new();

                // Generate decisions from issues
                for issue in issues {
                    if let Some(decision) = self.generate_decision_from_issue(issue).await {
                        decisions.push(decision);
                    }
                }

                // Generate decisions from recommendations
                for rec in recommendations {
                    if let Some(decision) = self.generate_decision_from_recommendation(rec).await {
                        decisions.push(decision);
                    }
                }

                // Generate summary decision if there are multiple issues
                if issues.len() > 1
                    && let Some(decision) = self
                        .generate_summary_decision(issues, recommendations)
                        .await
                    {
                        decisions.push(decision);
                    }

                decisions
            }
            ReviewResult::NoFindings { .. } => {
                // No decision needed when no findings
                Vec::new()
            }
            ReviewResult::Failed { error } => {
                // Generate a decision to report the failure
                vec![
                    Decision::new(
                        "Review Failed".to_string(),
                        format!("System review failed: {}", error),
                        "The automated review system encountered an error".to_string(),
                        DecisionType::HumanIntervention,
                        DecisionPriority::High,
                    )
                    .with_confidence(100.0),
                ]
            }
        }
    }

    /// Generate a decision from a detected issue.
    async fn generate_decision_from_issue(&self, issue: &DetectedIssue) -> Option<Decision> {
        let (decision_type, priority) = match issue.severity {
            IssueSeverity::Critical => (DecisionType::Alert, DecisionPriority::Critical),
            IssueSeverity::Warning => (DecisionType::Rule, DecisionPriority::High),
            IssueSeverity::Info => (DecisionType::DataCollection, DecisionPriority::Low),
        };

        let title = format!("{}: {}", issue.issue_type, issue.title);
        let description = issue.description.clone();
        let reasoning = format!(
            "Issue detected: {}. Affected entities: {}",
            issue.title,
            issue.affected_entities.join(", ")
        );

        let decision = Decision::new(title, description, reasoning, decision_type, priority);

        // Generate action based on issue type
        let action = self.generate_action_for_issue(issue).await?;
        Some(decision.with_action(action))
    }

    /// Generate a decision from a recommendation.
    async fn generate_decision_from_recommendation(
        &self,
        rec: &Recommendation,
    ) -> Option<Decision> {
        let decision_type = match rec.recommendation_type.as_str() {
            "check_offline_devices" => DecisionType::DeviceControl,
            "investigate_offline_devices" => DecisionType::HumanIntervention,
            _ => DecisionType::Rule,
        };

        let priority = match rec.confidence {
            c if c >= 80 => DecisionPriority::High,
            c if c >= 50 => DecisionPriority::Medium,
            _ => DecisionPriority::Low,
        };

        let mut decision = Decision::new(
            rec.title.clone(),
            rec.description.clone(),
            rec.expected_benefit.clone(),
            decision_type,
            priority,
        )
        .with_confidence(rec.confidence as f32);

        // Convert recommendation actions to decision actions
        for suggested_action in &rec.actions {
            let action = DecisionAction::new(
                suggested_action.action_type.clone(),
                suggested_action.description.clone(),
                suggested_action
                    .parameters
                    .clone()
                    .unwrap_or(serde_json::json!({})),
            );
            decision = decision.with_action(action);
        }

        Some(decision)
    }

    /// Generate a summary decision for multiple issues.
    async fn generate_summary_decision(
        &self,
        issues: &[DetectedIssue],
        recommendations: &[Recommendation],
    ) -> Option<Decision> {
        let critical_count = issues
            .iter()
            .filter(|i| matches!(i.severity, IssueSeverity::Critical))
            .count();
        let warning_count = issues
            .iter()
            .filter(|i| matches!(i.severity, IssueSeverity::Warning))
            .count();

        let title = format!("System Review Summary: {} issues detected", issues.len());
        let description = format!(
            "Found {} critical and {} warning issues. {} recommendations available.",
            critical_count,
            warning_count,
            recommendations.len()
        );
        let reasoning = "Multiple issues detected across the system. Review individual issues for details.".to_string();

        Some(
            Decision::new(
                title,
                description,
                reasoning,
                DecisionType::HumanIntervention,
                DecisionPriority::Medium,
            )
            .with_confidence(90.0),
        )
    }

    /// Generate an action for a detected issue.
    async fn generate_action_for_issue(&self, issue: &DetectedIssue) -> Option<DecisionAction> {
        let (action_type, description, parameters) = match issue.issue_type.as_str() {
            "device_offline" => (
                "notify_user".to_string(),
                format!("Notify about offline device: {}", issue.title),
                serde_json::json!({
                    "message": format!("Device {} is offline", issue.title),
                    "severity": "warning"
                }),
            ),
            "device_unhealthy" => (
                "check_device".to_string(),
                format!("Check device health: {}", issue.title),
                serde_json::json!({
                    "device_id": issue.affected_entities.first().unwrap_or(&"unknown".to_string())
                }),
            ),
            _ => (
                "log_issue".to_string(),
                format!("Log issue: {}", issue.title),
                serde_json::json!({
                    "issue": issue.title,
                    "severity": issue.severity.to_string()
                }),
            ),
        };

        Some(
            DecisionAction::new(action_type, description, parameters)
                .with_required(matches!(issue.severity, IssueSeverity::Critical)),
        )
    }

    /// Evaluate the confidence of a decision.
    pub async fn evaluate_confidence(&self, decision: &Decision) -> f32 {
        let mut confidence = decision.confidence;

        // Boost confidence based on priority
        match decision.priority {
            DecisionPriority::Critical => confidence = (confidence * 1.2).min(100.0),
            DecisionPriority::High => confidence = (confidence * 1.1).min(100.0),
            _ => {}
        }

        // Reduce confidence if actions are missing
        if decision.actions.is_empty() {
            confidence *= 0.7;
        }

        // Boost confidence if impact assessment is complete
        if !decision.impact.benefit.is_empty() {
            confidence = (confidence * 1.05).min(100.0);
        }

        confidence
    }

    /// Publish a decision to the event bus.
    pub async fn publish_decision(&self, decision: &Decision) {
        let event = NeoTalkEvent::LlmDecisionProposed {
            decision_id: decision.id.clone(),
            title: decision.title.clone(),
            description: decision.description.clone(),
            reasoning: decision.reasoning.clone(),
            actions: decision
                .actions
                .iter()
                .map(|a| {
                    ProposedAction::new(
                        a.action_type.clone(),
                        a.description.clone(),
                        a.parameters.clone(),
                    )
                })
                .collect(),
            confidence: decision.confidence,
            timestamp: chrono::Utc::now().timestamp(),
        };

        let _ = self
            .event_bus
            .publish_with_source(event, "decision_engine")
            .await;
    }

    /// Execute a decision automatically if conditions are met.
    pub async fn try_execute_decision(&self, decision: &Decision) -> Result<(), DecisionError> {
        if !decision.should_auto_execute() {
            return Err(DecisionError::NotExecutable);
        }

        tracing::info!(
            "Auto-executing decision: {} (confidence: {:.1}%)",
            decision.title,
            decision.confidence
        );

        let mut executed_actions = Vec::new();
        let mut failed_actions = Vec::new();
        let mut action_results = Vec::new();

        // Execute each action in the decision
        for action in &decision.actions {
            match self.execute_action(action).await {
                Ok(result) => {
                    executed_actions.push(action.id.clone());
                    action_results.push(result);
                    tracing::debug!("Executed action {}: {}", action.id, action.action_type);
                }
                Err(e) => {
                    failed_actions.push((action.id.clone(), e.to_string()));
                    tracing::error!("Failed to execute action {}: {}", action.id, e);

                    // Fail fast for required actions
                    if action.required {
                        break;
                    }
                }
            }
        }

        // Determine overall success
        let success = failed_actions.is_empty();
        let result = if success {
            Some(serde_json::json!({
                "executed_count": executed_actions.len(),
                "action_ids": executed_actions,
            }))
        } else {
            Some(serde_json::json!({
                "executed_count": executed_actions.len(),
                "failed_count": failed_actions.len(),
                "executed": executed_actions,
                "failed": failed_actions,
            }))
        };

        // Publish decision executed event
        let _ = self
            .event_bus
            .publish(NeoTalkEvent::LlmDecisionExecuted {
                decision_id: decision.id.clone(),
                success,
                result,
                timestamp: chrono::Utc::now().timestamp(),
            })
            .await;

        if success {
            // Save decision with executed status
            let mut executed_decision = decision.clone();
            executed_decision.status = DecisionStatus::Executed;
            self.save_decision(executed_decision).await;
            Ok(())
        } else {
            Err(DecisionError::ActionFailed(format!(
                "{} of {} actions failed",
                failed_actions.len(),
                decision.actions.len()
            )))
        }
    }

    /// Execute a single decision action.
    async fn execute_action(&self, action: &DecisionAction) -> Result<(), DecisionError> {
        match action.action_type.as_str() {
            "notify_user" => {
                self.execute_notify_action(action).await?;
            }
            "control_device" | "send_command" => {
                self.execute_device_control_action(action).await?;
            }
            "create_rule" => {
                self.execute_create_rule_action(action).await?;
            }
            "trigger_workflow" => {
                self.execute_trigger_workflow_action(action).await?;
            }
            "update_settings" => {
                self.execute_update_settings_action(action).await?;
            }
            "check_device" => {
                // This is a query action, just log it
                tracing::info!("Check device action: {}", action.description);
                // Could publish a device query event here
            }
            "log_issue" => {
                self.execute_log_action(action).await?;
            }
            _ => {
                tracing::warn!("Unknown action type: {}, logging only", action.action_type);
                self.execute_log_action(action).await?;
            }
        }
        Ok(())
    }

    /// Execute a notification action.
    async fn execute_notify_action(&self, action: &DecisionAction) -> Result<(), DecisionError> {
        let message = action
            .parameters
            .get("message")
            .and_then(|v| v.as_str())
            .unwrap_or(&action.description);

        let _ = self
            .event_bus
            .publish(NeoTalkEvent::AlertCreated {
                alert_id: uuid::Uuid::new_v4().to_string(),
                title: action.description.clone(),
                severity: action
                    .parameters
                    .get("severity")
                    .and_then(|v| v.as_str())
                    .unwrap_or("info")
                    .to_string(),
                message: message.to_string(),
                timestamp: chrono::Utc::now().timestamp(),
            })
            .await;

        Ok(())
    }

    /// Execute a device control action.
    async fn execute_device_control_action(
        &self,
        action: &DecisionAction,
    ) -> Result<(), DecisionError> {
        let device_id = action
            .parameters
            .get("device_id")
            .and_then(|v| v.as_str())
            .ok_or_else(|| DecisionError::InvalidDecision("Missing device_id".to_string()))?;

        let command = action
            .parameters
            .get("command")
            .or_else(|| action.parameters.get("command_name"))
            .and_then(|v| v.as_str())
            .ok_or_else(|| DecisionError::InvalidDecision("Missing command".to_string()))?;

        let params = action
            .parameters
            .get("params")
            .or_else(|| action.parameters.get("parameters"))
            .cloned()
            .unwrap_or(serde_json::json!({}));

        tracing::info!("Sending command '{}' to device '{}'", command, device_id);

        // Publish command event - the command processor will pick this up
        let _ = self
            .event_bus
            .publish(NeoTalkEvent::DeviceCommandResult {
                device_id: device_id.to_string(),
                command: command.to_string(),
                success: true,
                result: Some(serde_json::json!({
                    "action_id": action.id,
                    "description": action.description,
                    "params": params,
                })),
                timestamp: chrono::Utc::now().timestamp(),
            })
            .await;

        Ok(())
    }

    /// Execute a rule creation action.
    async fn execute_create_rule_action(
        &self,
        action: &DecisionAction,
    ) -> Result<(), DecisionError> {
        let dsl = action
            .parameters
            .get("dsl")
            .or_else(|| action.parameters.get("rule"))
            .and_then(|v| v.as_str())
            .ok_or_else(|| {
                DecisionError::InvalidDecision("Missing DSL for rule creation".to_string())
            })?;

        tracing::info!("Creating rule from DSL: {}", dsl);

        // For now, we just log this action
        // In a full implementation, this would interact with the rule engine
        // to compile and register the new rule
        tracing::info!("Rule DSL proposed: {}", dsl);

        // To integrate with RuleEngine:
        // 1. DecisionEngine needs a RuleEngine reference
        // 2. Call rule_engine.compile_rule() with the DSL
        // 3. Call rule_engine.add_rule() to register it
        // This requires architectural changes to pass RuleEngine through

        Ok(())
    }

    /// Execute a workflow trigger action.
    async fn execute_trigger_workflow_action(
        &self,
        action: &DecisionAction,
    ) -> Result<(), DecisionError> {
        let workflow_id = action
            .parameters
            .get("workflow_id")
            .and_then(|v| v.as_str())
            .ok_or_else(|| DecisionError::InvalidDecision("Missing workflow_id".to_string()))?;

        let params = action
            .parameters
            .get("params")
            .cloned()
            .unwrap_or(serde_json::json!({}));

        tracing::info!("Triggering workflow: {}", workflow_id);

        // Publish workflow triggered event
        let _ = self
            .event_bus
            .publish(NeoTalkEvent::WorkflowTriggered {
                workflow_id: workflow_id.to_string(),
                trigger_type: "llm_decision".to_string(),
                trigger_data: Some(params),
                execution_id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
            })
            .await;

        Ok(())
    }

    /// Execute a settings update action.
    async fn execute_update_settings_action(
        &self,
        action: &DecisionAction,
    ) -> Result<(), DecisionError> {
        let key = action
            .parameters
            .get("key")
            .and_then(|v| v.as_str())
            .ok_or_else(|| DecisionError::InvalidDecision("Missing setting key".to_string()))?;

        let value = action
            .parameters
            .get("value")
            .cloned()
            .unwrap_or(serde_json::json!(null));

        tracing::info!("Updating setting: {} = {:?}", key, value);

        // To integrate with settings manager:
        // 1. Use edge_ai_storage::SettingsStore for persistent settings
        // 2. Call settings_store.save_setting(key, value).await
        // SettingsStore is available via the API server's state
        tracing::info!("Settings update proposed: {} = {:?}", key, value);

        Ok(())
    }

    /// Execute a log action.
    async fn execute_log_action(&self, action: &DecisionAction) -> Result<(), DecisionError> {
        let severity = action
            .parameters
            .get("severity")
            .and_then(|v| v.as_str())
            .unwrap_or("info");

        let message = action
            .parameters
            .get("message")
            .or_else(|| action.parameters.get("issue"))
            .and_then(|v| v.as_str())
            .unwrap_or(&action.description);

        match severity {
            "error" => tracing::error!("{}", message),
            "warn" | "warning" => tracing::warn!("{}", message),
            "info" => tracing::info!("{}", message),
            "debug" => tracing::debug!("{}", message),
            _ => tracing::info!("{}", message),
        }

        Ok(())
    }

    /// Get decision history.
    pub async fn get_history(&self) -> Vec<Decision> {
        self.history.read().await.values().cloned().collect()
    }

    /// Get a specific decision by ID.
    pub async fn get_decision(&self, id: &str) -> Option<Decision> {
        self.history.read().await.get(id).cloned()
    }

    /// Save a decision to history.
    async fn save_decision(&self, decision: Decision) {
        let mut history = self.history.write().await;

        // Trim if over max size
        if history.len() >= self.config.max_history_size {
            // Remove oldest decisions (simple FIFO)
            let keys_to_remove: Vec<_> = history
                .keys()
                .take(history.len() - self.config.max_history_size + 1)
                .cloned()
                .collect();
            for key in keys_to_remove {
                history.remove(&key);
            }
        }

        history.insert(decision.id.clone(), decision);
    }
}

/// Errors that can occur in decision processing.
#[derive(Debug, thiserror::Error)]
pub enum DecisionError {
    #[error("Decision cannot be executed automatically")]
    NotExecutable,
    #[error("Action execution failed: {0}")]
    ActionFailed(String),
    #[error("Invalid decision: {0}")]
    InvalidDecision(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decision_creation() {
        let decision = Decision::new(
            "Test Decision".to_string(),
            "Test description".to_string(),
            "Test reasoning".to_string(),
            DecisionType::Rule,
            DecisionPriority::Medium,
        );

        assert_eq!(decision.title, "Test Decision");
        assert_eq!(decision.status, DecisionStatus::Proposed);
        assert_eq!(decision.confidence, 50.0);
    }

    #[test]
    fn test_decision_with_confidence() {
        let decision = Decision::new(
            "Test".to_string(),
            "Test".to_string(),
            "Test".to_string(),
            DecisionType::Rule,
            DecisionPriority::Medium,
        )
        .with_confidence(150.0);

        assert_eq!(decision.confidence, 100.0); // Clamped
    }

    #[test]
    fn test_should_auto_execute() {
        // High confidence + high priority = auto execute
        let decision = Decision::new(
            "Test".to_string(),
            "Test".to_string(),
            "Test".to_string(),
            DecisionType::Rule,
            DecisionPriority::High,
        )
        .with_confidence(85.0)
        .with_action(DecisionAction::new(
            "test".to_string(),
            "test".to_string(),
            serde_json::json!({}),
        ));

        assert!(decision.should_auto_execute());
    }

    #[test]
    fn test_should_not_auto_execute_low_confidence() {
        let decision = Decision::new(
            "Test".to_string(),
            "Test".to_string(),
            "Test".to_string(),
            DecisionType::Rule,
            DecisionPriority::High,
        )
        .with_confidence(70.0);

        assert!(!decision.should_auto_execute());
    }

    #[test]
    fn test_should_not_auto_execute_low_priority() {
        let decision = Decision::new(
            "Test".to_string(),
            "Test".to_string(),
            "Test".to_string(),
            DecisionType::Rule,
            DecisionPriority::Low,
        )
        .with_confidence(90.0);

        assert!(!decision.should_auto_execute());
    }

    #[test]
    fn test_decision_action_creation() {
        let action = DecisionAction::new(
            "test_action".to_string(),
            "Test action".to_string(),
            serde_json::json!({"key": "value"}),
        );

        assert_eq!(action.action_type, "test_action");
        assert!(!action.required);
    }

    #[test]
    fn test_priority_ordering() {
        assert!(DecisionPriority::Critical > DecisionPriority::High);
        assert!(DecisionPriority::High > DecisionPriority::Medium);
        assert!(DecisionPriority::Medium > DecisionPriority::Low);
    }

    #[test]
    fn test_impact_assessment() {
        let impact = ImpactAssessment {
            benefit: "Test benefit".to_string(),
            risks: vec!["Risk 1".to_string()],
            resources: vec!["Resource 1".to_string()],
            estimated_time: Some("1 hour".to_string()),
        };

        assert_eq!(impact.benefit, "Test benefit");
        assert_eq!(impact.risks.len(), 1);
    }
}
