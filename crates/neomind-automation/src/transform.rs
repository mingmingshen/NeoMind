//! Transform engine for processing device data.
//!
//! This module provides the execution engine for data transformations,
//! converting raw device JSON into standardized metrics.
//!
//! # AI-Native Design
//!
//! Transforms use JavaScript code generated by AI:
//! - User describes intent in natural language
//! - AI generates JavaScript transformation code
//! - Code executes in a sandboxed Boa JS context
//! - Results become virtual metrics

use crate::types::{
    TransformAutomation, TransformOperation, AggregationFunc,
    TimeWindow,
};
use crate::error::{AutomationError, Result};
use chrono::Utc;
use serde_json::Value;
use std::collections::HashMap;
use std::sync::Arc;

/// JavaScript-based transform executor using Boa engine
///
/// Executes user-written JavaScript code in a sandboxed environment.
/// The code receives `input` (raw device data) and should return transformed results.
pub struct JsTransformExecutor;

impl JsTransformExecutor {
    /// Create a new JS executor
    pub fn new() -> Self {
        JsTransformExecutor
    }

    /// Execute JavaScript transformation code
    ///
    /// # Arguments
    /// * `code` - JavaScript code to execute
    /// * `input` - Raw device data (passed as `input` variable)
    /// * `output_prefix` - Prefix for output metric names
    /// * `device_id` - Device ID for metrics
    /// * `timestamp` - Timestamp for metrics
    ///
    /// # Returns
    /// Vector of transformed metrics
    ///
    /// # JavaScript API
    ///
    /// The code has access to:
    /// - `input`: The raw device data (object)
    /// - Code can use `return` or simply evaluate to a value (last expression is returned)
    ///
    /// # Example
    /// ```javascript
    /// // Count detections by class
    /// const counts = {};
    /// for (const item of input.detections || []) {
    ///   const cls = item.cls || 'unknown';
    ///   counts[cls] = (counts[cls] || 0) + 1;
    /// }
    /// counts;  // Last expression is the return value
    /// ```
    ///
    /// Or with explicit return:
    /// ```javascript
    /// return (input.items || input.detections || []).length;
    /// ```
    pub fn execute(
        &self,
        code: &str,
        input: &Value,
        output_prefix: &str,
        device_id: &str,
        timestamp: i64,
    ) -> Result<Vec<TransformedMetric>> {
        use boa_engine::{context::Context, Source};

        // Create Boa context
        let mut context = Context::default();

        // Inject input data as JSON
        let input_json = serde_json::to_string(input)
            .map_err(|e| AutomationError::TransformError {
                operation: "JsTransform".to_string(),
                message: format!("Failed to serialize input: {}", e),
            })?;

        // Define the input variable
        let setup_code = format!("const input = {};", input_json);
        context.eval(Source::from_bytes(setup_code.as_bytes())).map_err(|e| {
            AutomationError::TransformError {
                operation: "JsTransform".to_string(),
                message: format!("Failed to set input: {}", e),
            }
        })?;

        // Wrap user code in a function to allow `return` statements
        let wrapped_code = format!(
            "(function() {{\n{}\n}})()",
            code
        );

        // Execute the transformation code
        let result = context.eval(Source::from_bytes(wrapped_code.as_bytes())).map_err(|e| {
            AutomationError::TransformError {
                operation: "JsTransform".to_string(),
                message: format!("JavaScript execution error: {}", e),
            }
        })?;

        // Convert result to Value
        let result_value = self.js_value_to_json(result, &mut context)?;

        // Convert result to metrics
        self.json_to_metrics(&result_value, output_prefix, device_id, timestamp)
    }

    /// Convert Boa value to JSON Value
    fn js_value_to_json(&self, value: boa_engine::JsValue, context: &mut boa_engine::context::Context) -> Result<Value> {
        // Try to convert to JSON representation using Boa's to_json method
        // Note: to_json requires a context reference and returns serde_json::Value directly
        let json_value = value.to_json(context).map_err(|e| {
            AutomationError::TransformError {
                operation: "JsTransform".to_string(),
                message: format!("Failed to convert JS value to JSON: {}", e),
            }
        })?;

        Ok(json_value)
    }

    /// Convert JSON result to vector of metrics
    ///
    /// Uses dot notation for namespacing: user returns {count: 5, fish: 3}
    /// becomes metrics: "transform.count", "transform.fish"
    fn json_to_metrics(
        &self,
        value: &Value,
        output_prefix: &str,
        device_id: &str,
        timestamp: i64,
    ) -> Result<Vec<TransformedMetric>> {
        let mut metrics = Vec::new();

        match value {
            // Object: create one metric per key with dot notation namespace
            Value::Object(obj) => {
                for (key, val) in obj.iter() {
                    let metric_name = format!("{}.{}", output_prefix, key);
                    let metric_value = value_as_f64(val)
                        .unwrap_or_else(|| {
                            val.to_string().chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0
                        });

                    tracing::debug!("Transform generated metric: {} = {} (device: {})", metric_name, metric_value, device_id);

                    metrics.push(TransformedMetric {
                        device_id: device_id.to_string(),
                        metric: metric_name,
                        value: metric_value,
                        timestamp,
                        quality: Some(1.0),
                    });
                }
            }

            // Array: create indexed metrics
            Value::Array(arr) => {
                for (index, val) in arr.iter().enumerate() {
                    let metric_name = format!("{}.{}", output_prefix, index);
                    let metric_value = value_as_f64(val).unwrap_or(0.0);

                    metrics.push(TransformedMetric {
                        device_id: device_id.to_string(),
                        metric: metric_name,
                        value: metric_value,
                        timestamp,
                        quality: Some(1.0),
                    });
                }
            }

            Value::Number(n) => {
                if let Some(f) = n.as_f64() {
                    metrics.push(TransformedMetric {
                        device_id: device_id.to_string(),
                        metric: format!("{}.value", output_prefix),
                        value: f,
                        timestamp,
                        quality: Some(1.0),
                    });
                }
            }

            Value::String(s) => {
                let value = s.parse::<f64>().unwrap_or_else(|_| {
                    s.chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0
                });
                metrics.push(TransformedMetric {
                    device_id: device_id.to_string(),
                    metric: format!("{}.value", output_prefix),
                    value,
                    timestamp,
                    quality: Some(1.0),
                });
            }

            Value::Bool(b) => {
                metrics.push(TransformedMetric {
                    device_id: device_id.to_string(),
                    metric: format!("{}.value", output_prefix),
                    value: if *b { 1.0 } else { 0.0 },
                    timestamp,
                    quality: Some(1.0),
                });
            }

            _ => {
                metrics.push(TransformedMetric {
                    device_id: device_id.to_string(),
                    metric: format!("{}.value", output_prefix),
                    value: 0.0,
                    timestamp,
                    quality: Some(0.0),
                });
            }
        }

        if metrics.is_empty() {
            metrics.push(TransformedMetric {
                device_id: device_id.to_string(),
                metric: format!("{}.value", output_prefix),
                value: 0.0,
                timestamp,
                quality: Some(0.0),
            });
        }

        Ok(metrics)
    }
}

impl Default for JsTransformExecutor {
    fn default() -> Self {
        Self::new()
    }
}

/// Result of a transform execution
#[derive(Debug, Clone, serde::Serialize)]
pub struct TransformResult {
    /// Output metrics produced
    pub metrics: Vec<TransformedMetric>,
    /// Any warnings generated during transformation
    pub warnings: Vec<String>,
}

/// A transformed metric ready for storage/publication
#[derive(Debug, Clone, serde::Serialize)]
pub struct TransformedMetric {
    /// Device ID
    pub device_id: String,
    /// Metric name
    pub metric: String,
    /// Metric value
    pub value: f64,
    /// Timestamp (Unix timestamp)
    pub timestamp: i64,
    /// Quality indicator (0-1)
    pub quality: Option<f32>,
}

/// Transform engine - executes data transformations
pub struct TransformEngine {
    /// Time-series data cache for window-based aggregations
    time_series_cache: Arc<tokio::sync::RwLock<TimeSeriesCache>>,
    /// JavaScript executor for AI-generated code
    js_executor: JsTransformExecutor,
}

impl Default for TransformEngine {
    fn default() -> Self {
        Self::new()
    }
}

impl TransformEngine {
    /// Create a new transform engine
    pub fn new() -> Self {
        Self {
            time_series_cache: Arc::new(tokio::sync::RwLock::new(TimeSeriesCache::new())),
            js_executor: JsTransformExecutor::new(),
        }
    }

    /// Get the JS executor (for testing purposes)
    pub fn js_executor(&self) -> &JsTransformExecutor {
        &self.js_executor
    }

    /// Process raw device data through applicable transforms
    ///
    /// # Arguments
    /// * `transforms` - List of transforms to apply (should be sorted by priority)
    /// * `device_id` - The device that produced the data
    /// * `device_type` - The type of the device
    /// * `raw_data` - The raw JSON data from the device
    ///
    /// # Returns
    /// Combined results from all applicable transforms
    pub async fn process_device_data(
        &self,
        transforms: &[TransformAutomation],
        device_id: &str,
        device_type: Option<&str>,
        raw_data: &Value,
    ) -> Result<TransformResult> {
        let mut all_metrics = Vec::new();
        let mut all_warnings = Vec::new();

        // Find applicable transforms (in priority order)
        let applicable_transforms: Vec<_> = transforms
            .iter()
            .filter(|t| t.applies_to_device(device_id, device_type))
            .collect();

        if applicable_transforms.is_empty() {
            return Ok(TransformResult {
                metrics: Vec::new(),
                warnings: Vec::new(),
            });
        }

        // Apply each applicable transform
        for transform in applicable_transforms {
            match self.execute_transform(transform, device_id, raw_data).await {
                Ok(result) => {
                    all_metrics.extend(result.metrics);
                    all_warnings.extend(result.warnings);
                }
                Err(e) => {
                    all_warnings.push(format!("Transform '{}' failed: {}", transform.metadata.name, e));
                }
            }
        }

        Ok(TransformResult {
            metrics: all_metrics,
            warnings: all_warnings,
        })
    }

    /// Execute a single transform
    async fn execute_transform(
        &self,
        transform: &TransformAutomation,
        device_id: &str,
        raw_data: &Value,
    ) -> Result<TransformResult> {
        let mut metrics = Vec::new();
        let mut warnings = Vec::new();
        let timestamp = Utc::now().timestamp();

        // Build the actual output prefix based on scope to avoid naming conflicts
        // - Global: "transform.{metric}"
        // - DeviceType: "transform.{device_type}.{metric}"
        // - Device: "transform.{metric}" (already isolated by device_id)
        let actual_prefix = match &transform.scope {
            crate::types::TransformScope::Global => {
                if transform.output_prefix.is_empty() {
                    "transform".to_string()
                } else {
                    transform.output_prefix.clone()
                }
            }
            crate::types::TransformScope::DeviceType(device_type) => {
                let base = if transform.output_prefix.is_empty() {
                    "transform"
                } else {
                    &transform.output_prefix
                };
                format!("{}.{}", base, device_type)
            }
            crate::types::TransformScope::Device(_) => {
                if transform.output_prefix.is_empty() {
                    "transform".to_string()
                } else {
                    transform.output_prefix.clone()
                }
            }
        };

        tracing::debug!(
            transform_id = %transform.metadata.id,
            transform_name = %transform.metadata.name,
            scope = ?transform.scope,
            output_prefix = %actual_prefix,
            device_id = %device_id,
            "Executing transform with scoped output prefix"
        );

        // Try JS-based execution first (new AI-native approach)
        if let Some(ref js_code) = transform.js_code
            && !js_code.is_empty() {
                match self.js_executor.execute(
                    js_code,
                    raw_data,
                    &actual_prefix,
                    device_id,
                    timestamp,
                ) {
                    Ok(js_metrics) => {
                        metrics.extend(js_metrics);
                    }
                    Err(e) => {
                        warnings.push(format!("JS execution failed: {}", e));
                    }
                }
                return Ok(TransformResult { metrics, warnings });
            }

        // Fall back to legacy operations
        if let Some(ref operations) = transform.operations {
            for operation in operations {
                match self.execute_operation(operation, device_id, timestamp, raw_data).await {
                    Ok(op_metrics) => metrics.extend(op_metrics),
                    Err(e) => warnings.push(format!("Operation failed: {}", e)),
                }
            }
        }

        Ok(TransformResult { metrics, warnings })
    }

    /// Execute a single transform operation
    async fn execute_operation(
        &self,
        operation: &TransformOperation,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        // Use a match with explicit async blocks to avoid recursion
        match operation {
            // ========== Legacy Operations ==========
            TransformOperation::Single { json_path, output_metric } => {
                self.execute_single(json_path, output_metric, device_id, timestamp, raw_data)
                    .await
                    .map(|m| vec![m])
            }

            TransformOperation::ArrayAggregation {
                json_path,
                aggregation,
                value_path,
                output_metric,
            } => {
                self.execute_array_aggregation(
                    json_path,
                    *aggregation,
                    value_path.as_deref(),
                    output_metric,
                    device_id,
                    timestamp,
                    raw_data,
                )
                .await
                .map(|m| vec![m])
            }

            TransformOperation::TimeSeriesAggregation {
                source_metric,
                window,
                aggregation,
                output_metric,
            } => {
                self.execute_time_series_aggregation(
                    source_metric,
                    window,
                    *aggregation,
                    output_metric,
                    device_id,
                )
                .await
                .map(|m| vec![m])
            }

            TransformOperation::Reference {
                source_device,
                source_metric: _,
                output_metric,
            } => {
                // Reference operations need external data - return placeholder
                Ok(vec![TransformedMetric {
                    device_id: source_device.clone(),
                    metric: output_metric.clone(),
                    value: 0.0,
                    timestamp,
                    quality: None,
                }])
            }

            TransformOperation::Custom {
                wasm_module_id: _,
                function_name: _,
                parameters: _,
                output_metrics,
            } => {
                // Custom WASM execution - not yet implemented
                Ok(output_metrics
                    .iter()
                    .map(|m| TransformedMetric {
                        device_id: device_id.to_string(),
                        metric: m.clone(),
                        value: 0.0,
                        timestamp,
                        quality: None,
                    })
                    .collect())
            }

            TransformOperation::MultiOutput { operations } => {
                // Inline the multioutput logic to avoid recursion
                let mut all_metrics = Vec::new();
                for op in operations {
                    let result = match op {
                        TransformOperation::Single { json_path, output_metric } => {
                            self.execute_single(json_path, output_metric, device_id, timestamp, raw_data)
                                .await
                                .map(|m| vec![m])
                        }
                        TransformOperation::ArrayAggregation {
                            json_path,
                            aggregation,
                            value_path,
                            output_metric,
                        } => {
                            self.execute_array_aggregation(
                                json_path,
                                *aggregation,
                                value_path.as_deref(),
                                output_metric,
                                device_id,
                                timestamp,
                                raw_data,
                            )
                            .await
                            .map(|m| vec![m])
                        }
                        TransformOperation::TimeSeriesAggregation {
                            source_metric,
                            window,
                            aggregation,
                            output_metric,
                        } => {
                            self.execute_time_series_aggregation(
                                source_metric,
                                window,
                                *aggregation,
                                output_metric,
                                device_id,
                            )
                            .await
                            .map(|m| vec![m])
                        }
                        TransformOperation::Reference {
                            source_device,
                            source_metric: _,
                            output_metric,
                        } => {
                            Ok(vec![TransformedMetric {
                                device_id: source_device.clone(),
                                metric: output_metric.clone(),
                                value: 0.0,
                                timestamp,
                                quality: None,
                            }])
                        }
                        TransformOperation::Custom {
                            output_metrics,
                            ..
                        } => {
                            Ok(output_metrics
                                .iter()
                                .map(|m| TransformedMetric {
                                    device_id: device_id.to_string(),
                                    metric: m.clone(),
                                    value: 0.0,
                                    timestamp,
                                    quality: None,
                                })
                                .collect())
                        }
                        // Skip nested MultiOutput to avoid deep recursion
                        TransformOperation::MultiOutput { .. } => continue,
                        _ => continue, // Skip other types for now
                    };
                    match result {
                        Ok(mut m) => all_metrics.append(&mut m),
                        Err(_) => continue,
                    }
                }
                Ok(all_metrics)
            }

            // ========== New Expression-Based Operations ==========

            TransformOperation::Extract { from, output, as_type } => {
                self.execute_extract(from, output, *as_type, device_id, timestamp, raw_data)
                    .await
                    .map(|m| vec![m])
            }

            TransformOperation::Map { over, template, output, filter } => {
                self.execute_map(over, template, output, filter.as_deref(), device_id, timestamp, raw_data)
                    .await
            }

            TransformOperation::Reduce { over, using, value, output } => {
                self.execute_reduce(over, *using, value.as_deref(), output, device_id, timestamp, raw_data)
                    .await
                    .map(|m| vec![m])
            }

            TransformOperation::Format { template, output, from } => {
                self.execute_format(template, output, from.as_deref(), device_id, timestamp, raw_data)
                    .await
                    .map(|m| vec![m])
            }

            TransformOperation::Compute { expression, output } => {
                self.execute_compute(expression, output, device_id, timestamp, raw_data)
                    .await
                    .map(|m| vec![m])
            }

            TransformOperation::Pipeline { steps, output } => {
                self.execute_pipeline(steps, output, device_id, timestamp, raw_data).await
            }

            TransformOperation::Fork { branches } => {
                self.execute_fork(branches, device_id, timestamp, raw_data).await
            }

            TransformOperation::If { condition, then, else_, output } => {
                self.execute_if(condition, then, else_.as_deref(), output, device_id, timestamp, raw_data)
                    .await
            }

            // ========== Advanced Data Processing Operations ==========

            TransformOperation::GroupBy { over, key, using, value, output } => {
                self.execute_group_by(over, key, *using, value.as_deref(), output, device_id, timestamp, raw_data)
                    .await
            }

            TransformOperation::Decode { from, format, output } => {
                self.execute_decode(from, *format, output, device_id, timestamp, raw_data)
                    .await
            }

            TransformOperation::Encode { from, format, output } => {
                self.execute_encode(from, *format, output, device_id, timestamp, raw_data)
                    .await
            }
        }
    }

    /// Execute Extract operation - extract value using JSONPath
    async fn execute_extract(
        &self,
        from: &str,
        output: &str,
        _as_type: Option<crate::types::TargetDataType>,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        let value = self.extract_value_by_path(raw_data, from)?;
        let float_value = value_as_f64(&value)
            .ok_or_else(|| AutomationError::TransformError {
                operation: "Extract".to_string(),
                message: format!("Value at '{}' is not a number: {}", from, value),
            })?;

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value: float_value,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Execute Map operation - transform array elements using template
    async fn execute_map(
        &self,
        over: &str,
        template: &str,
        output_pattern: &str,
        _where_clause: Option<&str>,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        let array_value = self.extract_value_by_path(raw_data, over)?;

        let array = match &array_value {
            Value::Array(arr) => arr,
            _ => {
                return Err(AutomationError::TransformError {
                    operation: "Map".to_string(),
                    message: format!("Value at '{}' is not an array", over),
                })
            }
        };

        let mut metrics = Vec::new();
        for (index, item) in array.iter().enumerate() {
            // Render template with item context
            let rendered = self.render_template(template, raw_data, Some(item), index);
            let rendered_output = self.render_template(output_pattern, raw_data, Some(item), index);

            // Try to parse as number, otherwise use as string (convert to f64 via hash for now)
            let value = if let Ok(num) = rendered.trim().parse::<f64>() {
                num
            } else {
                // Use a simple hash for non-numeric values
                rendered.chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0
            };

            metrics.push(TransformedMetric {
                device_id: device_id.to_string(),
                metric: rendered_output,
                value,
                timestamp,
                quality: Some(1.0),
            });
        }

        Ok(metrics)
    }

    /// Execute Reduce operation - aggregate array
    async fn execute_reduce(
        &self,
        over: &str,
        aggregation: AggregationFunc,
        value_path: Option<&str>,
        output: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        self.execute_array_aggregation(over, aggregation, value_path, output, device_id, timestamp, raw_data).await
    }

    /// Execute Format operation - template string formatting
    async fn execute_format(
        &self,
        template: &str,
        output: &str,
        from: Option<&str>,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        let data = if let Some(path) = from {
            self.extract_value_by_path(raw_data, path)?
        } else {
            raw_data.clone()
        };

        let rendered = self.render_template(template, &data, None, 0);

        // Try to parse as number, otherwise use hash
        let value = if let Ok(num) = rendered.trim().parse::<f64>() {
            num
        } else {
            // Use hash for string values
            rendered.chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0
        };

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Execute Compute operation - mathematical expression
    async fn execute_compute(
        &self,
        expression: &str,
        output: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        // Simple expression evaluator
        // Supports: {{path}}, +, -, *, /, ( )
        let rendered = self.render_template(expression, raw_data, None, 0);

        let value = self.evaluate_expression(&rendered, raw_data)
            .unwrap_or_else(|_| rendered.trim().parse().unwrap_or(0.0));

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Execute Pipeline operation - chain operations
    async fn execute_pipeline(
        &self,
        _steps: &[TransformOperation],
        final_output: &str,
        device_id: &str,
        timestamp: i64,
        _raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        // Simplified: Pipeline is not fully implemented yet
        // Just return a placeholder metric
        Ok(vec![TransformedMetric {
            device_id: device_id.to_string(),
            metric: final_output.to_string(),
            value: 0.0,
            timestamp,
            quality: Some(1.0),
        }])
    }

    /// Execute Fork operation - parallel branches
    async fn execute_fork(
        &self,
        _branches: &[TransformOperation],
        _device_id: &str,
        _timestamp: i64,
        _raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        // Simplified: Fork is not fully implemented yet
        Ok(vec![])
    }

    /// Execute If operation - conditional execution
    async fn execute_if(
        &self,
        _condition: &str,
        _then_op: &TransformOperation,
        _else_op: Option<&TransformOperation>,
        output: &str,
        device_id: &str,
        timestamp: i64,
        _raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        // Simplified: If is not fully implemented yet
        Ok(vec![TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value: 0.0,
            timestamp,
            quality: Some(1.0),
        }])
    }

    /// Render a template string with variable substitution
    fn render_template(&self, template: &str, root: &Value, item: Option<&Value>, index: usize) -> String {
        let mut result = template.to_string();

        // Replace {{variable}} patterns
        while let Some(start) = result.find("{{") {
            let end = match result[start..].find("}}") {
                Some(pos) => start + pos + 2,
                None => break,
            };

            let var_name = &result[start + 2..end - 2].trim();

            // Special variables
            let replacement = if var_name == &"item" {
                item.and_then(value_as_f64)
                    .map(|v| v.to_string())
                    .unwrap_or_else(|| item.map(|i| i.to_string()).unwrap_or_default())
            } else if var_name == &"index" {
                index.to_string()
            } else {
                // JSONPath extraction
                let path = if var_name.starts_with("$") {
                    var_name.to_string()
                } else {
                    format!("$.{}", var_name)
                };

                self.extract_value_by_path(root, &path)
                    .map(|v| {
                        if v.is_string() {
                            v.as_str().unwrap().to_string()
                        } else {
                            v.to_string()
                        }
                    })
                    .unwrap_or_default()
            };

            result.replace_range(start..end, &replacement);
        }

        result
    }

    /// Evaluate a mathematical expression
    fn evaluate_expression(&self, expr: &str, data: &Value) -> Result<f64> {
        // Very simple expression evaluator
        // In production, use a proper expression parsing library
        let sanitized = expr
            .replace("{{", "")
            .replace("}}", "")
            .trim().to_string();

        // Try to extract value and evaluate
        if let Ok(num) = sanitized.parse::<f64>() {
            return Ok(num);
        }

        // Try to extract from data
        match self.extract_value_by_path(data, &sanitized) {
            Ok(value) => value_as_f64(&value)
                .ok_or_else(|| AutomationError::TransformError {
                    operation: "Compute".to_string(),
                    message: format!("Cannot convert to number: {}", value),
                }),
            Err(_) => Ok(0.0),
        }
    }

    /// Execute a Single operation - extract a value using JSONPath-like syntax
    async fn execute_single(
        &self,
        json_path: &str,
        output_metric: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        let value = self.extract_value_by_path(raw_data, json_path)?;

        // Convert to f64
        let float_value = value_as_f64(&value)
            .ok_or_else(|| AutomationError::TransformError {
                operation: "Single".to_string(),
                message: format!("Value at '{}' is not a number: {}", json_path, value),
            })?;

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output_metric.to_string(),
            value: float_value,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Execute an ArrayAggregation operation
    async fn execute_array_aggregation(
        &self,
        json_path: &str,
        aggregation: AggregationFunc,
        value_path: Option<&str>,
        output_metric: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<TransformedMetric> {
        // Extract array
        let array_value = self.extract_value_by_path(raw_data, json_path)?;

        let array = match &array_value {
            Value::Array(arr) => arr,
            _ => {
                return Err(AutomationError::TransformError {
                    operation: "ArrayAggregation".to_string(),
                    message: format!("Value at '{}' is not an array", json_path),
                })
            }
        };

        if array.is_empty() {
            return Err(AutomationError::TransformError {
                operation: "ArrayAggregation".to_string(),
                message: format!("Array at '{}' is empty", json_path),
            });
        }

        // Extract values from array elements
        let mut values = Vec::new();
        for element in array {
            let value = if let Some(path) = value_path {
                self.extract_value_by_path(element, path)?
            } else {
                element.clone()
            };

            if let Some(f) = value_as_f64(&value) {
                values.push(f);
            }
        }

        if values.is_empty() {
            return Err(AutomationError::TransformError {
                operation: "ArrayAggregation".to_string(),
                message: "No numeric values found in array".to_string(),
            });
        }

        // Compute aggregation
        let result = self.compute_aggregation(&values, aggregation)?;

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output_metric.to_string(),
            value: result,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Execute a TimeSeriesAggregation operation
    async fn execute_time_series_aggregation(
        &self,
        source_metric: &str,
        window: &TimeWindow,
        aggregation: AggregationFunc,
        output_metric: &str,
        device_id: &str,
    ) -> Result<TransformedMetric> {
        // Get historical data points from cache
        let cache = self.time_series_cache.read().await;
        let data_points = cache.get_window(device_id, source_metric, window.duration_secs);

        if data_points.is_empty() {
            return Err(AutomationError::TransformError {
                operation: "TimeSeriesAggregation".to_string(),
                message: format!("No data points found for '{}.{}'", device_id, source_metric),
            });
        }

        let values: Vec<f64> = data_points.iter().map(|p| p.value).collect();
        let result = self.compute_aggregation(&values, aggregation)?;

        let timestamp = Utc::now().timestamp();

        Ok(TransformedMetric {
            device_id: device_id.to_string(),
            metric: output_metric.to_string(),
            value: result,
            timestamp,
            quality: Some(1.0),
        })
    }

    /// Compute aggregation over a set of values
    fn compute_aggregation(&self, values: &[f64], aggregation: AggregationFunc) -> Result<f64> {
        if values.is_empty() {
            return Err(AutomationError::TransformError {
                operation: format!("{:?}", aggregation),
                message: "Cannot aggregate empty value set".to_string(),
            });
        }

        let result = match aggregation {
            AggregationFunc::Mean => values.iter().sum::<f64>() / values.len() as f64,
            AggregationFunc::Max => values.iter().fold(f64::NAN, |a, &b| a.max(b)),
            AggregationFunc::Min => values.iter().fold(f64::NAN, |a, &b| a.min(b)),
            AggregationFunc::Sum => values.iter().sum(),
            AggregationFunc::Count => values.len() as f64,
            AggregationFunc::First => values[0],
            AggregationFunc::Last => values[values.len() - 1],
            AggregationFunc::Median => {
                let mut sorted = values.to_vec();
                sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
                sorted[sorted.len() / 2]
            }
            AggregationFunc::StdDev => {
                let mean = values.iter().sum::<f64>() / values.len() as f64;
                let variance = values.iter()
                    .map(|&x| (x - mean).powi(2))
                    .sum::<f64>() / values.len() as f64;
                variance.sqrt()
            }
            AggregationFunc::Trend => {
                // Simple trend: positive if last > first, negative if last < first, zero if equal
                if values.len() < 2 {
                    0.0
                } else {
                    let last = values[values.len() - 1];
                    let first = values[0];
                    if last > first {
                        1.0
                    } else if last < first {
                        -1.0
                    } else {
                        0.0
                    }
                }
            }
            AggregationFunc::Delta => {
                if values.len() < 2 {
                    0.0
                } else {
                    values[values.len() - 1] - values[0]
                }
            }
            AggregationFunc::Rate => {
                // Rate of change per second (assuming 1-second intervals)
                if values.len() < 2 {
                    0.0
                } else {
                    (values[values.len() - 1] - values[0]) / (values.len() - 1) as f64
                }
            }
        };

        Ok(result)
    }

    /// Extract a value from JSON using a simple path notation
    ///
    /// Supports:
    /// - "$" - root
    /// - "$.field" - direct field access
    /// - "$.field.nested" - nested field access
    /// - "$.field[0]" - array access with index
    /// - "$.field[]" - array wildcard (returns first element or all elements as array)
    /// - "$.field[0]" or "$.field.0" - dot notation for array index
    fn extract_value_by_path(&self, data: &Value, path: &str) -> Result<Value> {
        let path = path.trim();
        let mut current = data;

        // Handle root
        if path == "$" || path.is_empty() {
            return Ok(current.clone());
        }

        // Remove leading "$."
        let path_parts = if path.starts_with("$.") {
            &path[2..]
        } else if path.starts_with("$") {
            &path[1..]
        } else {
            path
        };

        // Split by "." and traverse
        for part in path_parts.split('.') {
            if part.is_empty() {
                continue;
            }

            // Handle array indexing: "field[0]" or "field[]" for wildcard
            if let Some(bracket_pos) = part.find('[') {
                let field = &part[..bracket_pos];
                let index_part = &part[bracket_pos..];

                // Get the field first
                current = current
                    .get(field)
                    .ok_or_else(|| AutomationError::TransformError {
                        operation: "PathExtract".to_string(),
                        message: format!("Field '{}' not found", field),
                    })?;

                // Parse array index or wildcard
                if let Some(end_bracket) = index_part.find(']') {
                    let index_str = &index_part[1..end_bracket];

                    if index_str.is_empty() {
                        // Wildcard "[]" - return the array as-is, or first element
                        if let Value::Array(arr) = current {
                            current = if arr.len() == 1 {
                                &arr[0]
                            } else {
                                current
                            };
                        }
                        // If not an array, keep current as-is
                    } else {
                        // Numeric index
                        let index: usize = index_str.parse().map_err(|_| AutomationError::TransformError {
                            operation: "PathExtract".to_string(),
                            message: format!("Invalid array index: {}", index_str),
                        })?;

                        if let Value::Array(arr) = current {
                            current = arr.get(index).ok_or_else(|| AutomationError::TransformError {
                                operation: "PathExtract".to_string(),
                                message: format!("Array index {} out of bounds (len: {})", index, arr.len()),
                            })?;
                        } else {
                            return Err(AutomationError::TransformError {
                                operation: "PathExtract".to_string(),
                                message: format!("Field '{}' is not an array", field),
                            });
                        }
                    }
                } else {
                    return Err(AutomationError::TransformError {
                        operation: "PathExtract".to_string(),
                        message: format!("Unclosed bracket in path part: {}", part),
                    });
                }
            } else if let Ok(index) = part.parse::<usize>() {
                // Handle numeric array index in dot notation: "field.0"
                if let Value::Array(arr) = current {
                    current = arr.get(index).ok_or_else(|| AutomationError::TransformError {
                        operation: "PathExtract".to_string(),
                        message: format!("Array index {} out of bounds (len: {})", index, arr.len()),
                    })?;
                } else {
                    return Err(AutomationError::TransformError {
                        operation: "PathExtract".to_string(),
                        message: format!("Cannot index non-array with {}", index),
                    });
                }
            } else {
                // Regular field access
                current = current.get(part).ok_or_else(|| AutomationError::TransformError {
                    operation: "PathExtract".to_string(),
                    message: format!("Field '{}' not found", part),
                })?;
            }
        }

        Ok(current.clone())
    }

    /// Add a data point to the time-series cache (for TimeSeriesAggregation)
    pub async fn add_time_series_point(
        &self,
        device_id: &str,
        metric: &str,
        value: f64,
        timestamp: i64,
    ) {
        let mut cache = self.time_series_cache.write().await;
        cache.add_point(device_id, metric, value, timestamp);
    }

    /// Execute GroupBy operation - group array elements by key and aggregate
    async fn execute_group_by(
        &self,
        over: &str,
        key: &str,
        aggregation: AggregationFunc,
        value_path: Option<&str>,
        output_pattern: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        let array_value = self.extract_value_by_path(raw_data, over)?;

        let array = match &array_value {
            Value::Array(arr) => arr,
            _ => {
                return Err(AutomationError::TransformError {
                    operation: "GroupBy".to_string(),
                    message: format!("Value at '{}' is not an array", over),
                })
            }
        };

        // Group by key and collect values
        use std::collections::HashMap;
        let mut groups: HashMap<String, Vec<f64>> = HashMap::new();

        for item in array {
            // Get the group key
            let group_key = if let Some(key_field) = item.get(key) {
                match key_field {
                    Value::String(s) => s.clone(),
                    Value::Number(n) => n.to_string(),
                    Value::Bool(b) => b.to_string(),
                    _ => "unknown".to_string(),
                }
            } else {
                continue;
            };

            // Get the value to aggregate (if specified)
            let item_value = if let Some(path) = value_path {
                match self.extract_value_by_path(item, path) {
                    Ok(v) => value_as_f64(&v),
                    Err(_) => None,
                }
            } else {
                // For count aggregation, use 1.0 for each item
                Some(1.0)
            };

            if let Some(v) = item_value {
                groups.entry(group_key).or_default().push(v);
            }
        }

        // Compute aggregation for each group
        let mut metrics = Vec::new();
        for (group_key, values) in groups {
            let aggregated = self.compute_aggregation(&values, aggregation)?;
            let metric_name = format!("{}_{}", output_pattern, group_key);

            metrics.push(TransformedMetric {
                device_id: device_id.to_string(),
                metric: metric_name,
                value: aggregated,
                timestamp,
                quality: Some(1.0),
            });
        }

        Ok(metrics)
    }

    /// Execute Decode operation - convert encoded data to JSON
    async fn execute_decode(
        &self,
        from: &str,
        format: crate::types::DecodeFormat,
        output: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        let encoded_value = self.extract_value_by_path(raw_data, from)?;

        let encoded_str = match &encoded_value {
            Value::String(s) => s.as_str(),
            _ => {
                return Err(AutomationError::TransformError {
                    operation: "Decode".to_string(),
                    message: format!("Value at '{}' is not a string", from),
                })
            }
        };

        let decoded = match format {
            crate::types::DecodeFormat::Hex => {
                // Hex string to bytes to string
                match hex::decode(encoded_str) {
                    Ok(bytes) => String::from_utf8(bytes).unwrap_or_default(),
                    Err(e) => {
                        return Err(AutomationError::TransformError {
                            operation: "Decode".to_string(),
                            message: format!("Invalid hex string: {}", e),
                        })
                    }
                }
            }
            crate::types::DecodeFormat::Base64 => {
                // Base64 to string
                use base64::Engine;
                let engine = base64::engine::general_purpose::STANDARD;
                match engine.decode(encoded_str) {
                    Ok(bytes) => String::from_utf8(bytes).unwrap_or_default(),
                    Err(e) => {
                        return Err(AutomationError::TransformError {
                            operation: "Decode".to_string(),
                            message: format!("Invalid base64 string: {}", e),
                        })
                    }
                }
            }
            crate::types::DecodeFormat::Bytes => {
                // Already a string, assume UTF-8
                encoded_str.to_string()
            }
            crate::types::DecodeFormat::Url => {
                // URL decode
                match urlencoding::decode(encoded_str) {
                    Ok(s) => s.into_owned(),
                    Err(e) => {
                        return Err(AutomationError::TransformError {
                            operation: "Decode".to_string(),
                            message: format!("Invalid URL encoding: {}", e),
                        })
                    }
                }
            }
            crate::types::DecodeFormat::Csv => {
                // CSV parsing - return as-is for now
                encoded_str.to_string()
            }
        };

        // Try to parse as JSON, otherwise use as string
        let json_value: Value = if let Ok(v) = serde_json::from_str(&decoded) {
            v
        } else {
            Value::String(decoded.clone())
        };

        // Convert to f64 (use hash for non-numeric)
        let value = value_as_f64(&json_value).unwrap_or_else(|| {
            decoded.chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0
        });

        Ok(vec![TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value,
            timestamp,
            quality: Some(1.0),
        }])
    }

    /// Execute Encode operation - convert JSON to encoded format
    async fn execute_encode(
        &self,
        from: &str,
        format: crate::types::DecodeFormat,
        output: &str,
        device_id: &str,
        timestamp: i64,
        raw_data: &Value,
    ) -> Result<Vec<TransformedMetric>> {
        let value = self.extract_value_by_path(raw_data, from)?;

        let to_encode = match &value {
            Value::String(s) => s.clone(),
            _ => value.to_string(),
        };

        let encoded = match format {
            crate::types::DecodeFormat::Hex => {
                hex::encode(to_encode)
            }
            crate::types::DecodeFormat::Base64 => {
                use base64::Engine;
                base64::engine::general_purpose::STANDARD.encode(to_encode)
            }
            crate::types::DecodeFormat::Bytes => to_encode,
            crate::types::DecodeFormat::Url => {
                urlencoding::encode(&to_encode).into_owned()
            }
            crate::types::DecodeFormat::Csv => to_encode,
        };

        // Use hash for encoded string value
        let value = encoded.chars().map(|c| c as u32 as f64).sum::<f64>() % 10000.0;

        Ok(vec![TransformedMetric {
            device_id: device_id.to_string(),
            metric: output.to_string(),
            value,
            timestamp,
            quality: Some(1.0),
        }])
    }
}

/// Convert a JSON value to f64 if possible
fn value_as_f64(value: &Value) -> Option<f64> {
    match value {
        Value::Number(n) => n.as_f64(),
        Value::String(s) => s.parse().ok(),
        Value::Bool(b) => Some(if *b { 1.0 } else { 0.0 }),
        Value::Null => None,
        Value::Array(_) | Value::Object(_) => None,
    }
}

/// Time-series data cache for window-based aggregations
#[derive(Debug)]
struct TimeSeriesCache {
    /// Store data points as (device_id, metric) -> Vec<(timestamp, value)>
    data: HashMap<(String, String), Vec<(i64, f64)>>,
    /// Maximum number of points per metric
    max_points_per_metric: usize,
}

impl TimeSeriesCache {
    fn new() -> Self {
        Self {
            data: HashMap::new(),
            max_points_per_metric: 1000,
        }
    }

    /// Add a data point to the cache
    fn add_point(&mut self, device_id: &str, metric: &str, value: f64, timestamp: i64) {
        let key = (device_id.to_string(), metric.to_string());
        let points = self.data.entry(key).or_default();
        points.push((timestamp, value));

        // Sort by timestamp and keep only recent points
        points.sort_by_key(|(ts, _)| *ts);
        if points.len() > self.max_points_per_metric {
            *points = points.split_off(points.len() - self.max_points_per_metric);
        }
    }

    /// Get data points within a time window
    fn get_window(&self, device_id: &str, metric: &str, window_secs: u64) -> Vec<DataPoint> {
        let key = (device_id.to_string(), metric.to_string());
        let cutoff = Utc::now().timestamp() - window_secs as i64;

        self.data
            .get(&key)
            .map(|points| {
                points
                    .iter()
                    .filter(|(ts, _)| *ts >= cutoff)
                    .map(|(ts, v)| DataPoint { timestamp: *ts, value: *v })
                    .collect()
            })
            .unwrap_or_default()
    }
}

struct DataPoint {
    timestamp: i64,
    value: f64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use crate::TransformScope;

    #[test]
    fn test_extract_value_by_path() {
        let engine = TransformEngine::new();
        let data = json!({
            "temperature": 25.5,
            "nested": {
                "value": 42
            },
            "array": [1, 2, 3],
            "objects": [{"temp": 20}, {"temp": 25}]
        });

        // Test root
        assert_eq!(engine.extract_value_by_path(&data, "$").unwrap(), data);

        // Test direct field
        assert_eq!(
            engine.extract_value_by_path(&data, "$.temperature").unwrap(),
            json!(25.5)
        );

        // Test nested
        assert_eq!(
            engine.extract_value_by_path(&data, "$.nested.value").unwrap(),
            json!(42)
        );

        // Test array access
        assert_eq!(
            engine.extract_value_by_path(&data, "$.array[0]").unwrap(),
            json!(1)
        );
    }

    #[test]
    fn test_compute_aggregation() {
        let engine = TransformEngine::new();
        let values = vec![10.0, 20.0, 30.0, 40.0, 50.0];

        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Mean).unwrap(), 30.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Max).unwrap(), 50.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Min).unwrap(), 10.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Sum).unwrap(), 150.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Count).unwrap(), 5.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::First).unwrap(), 10.0);
        assert_eq!(engine.compute_aggregation(&values, AggregationFunc::Last).unwrap(), 50.0);
    }

    #[test]
    fn test_compute_aggregation_trend() {
        let engine = TransformEngine::new();
        let increasing = vec![10.0, 20.0, 30.0, 40.0, 50.0];
        let decreasing = vec![50.0, 40.0, 30.0, 20.0, 10.0];
        let constant = vec![25.0, 25.0, 25.0, 25.0];

        assert_eq!(engine.compute_aggregation(&increasing, AggregationFunc::Trend).unwrap(), 1.0);
        assert_eq!(engine.compute_aggregation(&decreasing, AggregationFunc::Trend).unwrap(), -1.0);
        assert_eq!(engine.compute_aggregation(&constant, AggregationFunc::Trend).unwrap(), 0.0);
    }

    #[test]
    fn test_execute_single() {
        let engine = TransformEngine::new();
        let data = json!({"temperature": 25.5, "humidity": 65});

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(engine.execute_single("$.temperature", "temp", "sensor1", 1234567890, &data))
            .unwrap();

        assert_eq!(result.device_id, "sensor1");
        assert_eq!(result.metric, "temp");
        assert_eq!(result.value, 25.5);
        assert_eq!(result.timestamp, 1234567890);
    }

    #[test]
    fn test_execute_array_aggregation() {
        let engine = TransformEngine::new();
        let data = json!({
            "sensors": [
                {"temp": 20.0},
                {"temp": 25.0},
                {"temp": 30.0}
            ]
        });

        let result = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(engine.execute_array_aggregation(
                "$.sensors",
                AggregationFunc::Mean,
                Some("temp"),
                "avg_temp",
                "sensor1",
                1234567890,
                &data,
            ))
            .unwrap();

        assert_eq!(result.metric, "avg_temp");
        assert_eq!(result.value, 25.0); // (20 + 25 + 30) / 3
    }

    #[test]
    fn test_transform_scope_priority() {
        assert_eq!(TransformScope::Global.priority(), 0);
        assert_eq!(TransformScope::DeviceType("sensor".to_string()).priority(), 1);
        assert_eq!(TransformScope::Device("sensor1".to_string()).priority(), 2);
    }

    #[test]
    fn test_transform_applies_to_device() {
        let transform = TransformAutomation::new(
            "test",
            "Test Transform",
            TransformScope::DeviceType("sensor".to_string()),
        );

        // Device type matches
        assert!(transform.applies_to_device("sensor1", Some("sensor")));

        // Device type doesn't match
        assert!(!transform.applies_to_device("sensor1", Some("actuator")));

        // No device type provided - doesn't match DeviceType scope
        assert!(!transform.applies_to_device("sensor1", None));

        // Global scope applies to all
        let global_transform = TransformAutomation::new(
            "test",
            "Test",
            TransformScope::Global,
        );
        assert!(global_transform.applies_to_device("any-device", None));
        assert!(global_transform.applies_to_device("any-device", Some("sensor")));
    }
}
